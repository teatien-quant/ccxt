# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
import hashlib
import math
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import BadSymbol
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import ExchangeNotAvailable
from ccxt.base.errors import OnMaintenance
from ccxt.base.errors import RequestTimeout


class huobipro(Exchange):

    def describe(self):
        return self.deep_extend(super(huobipro, self).describe(), {
            'id': 'huobipro',
            'name': 'Huobi Pro',
            'countries': ['CN'],
            'rateLimit': 2000,
            'userAgent': self.userAgents['chrome39'],
            'version': 'v1',
            'accounts': None,
            'accountsById': None,
            'hostname': 'api.huobi.pro',  # api.testnet.huobi.pro
            'pro': True,
            'has': {
                'CORS': False,
                'fetchTickers': True,
                'fetchDepositAddress': True,
                'fetchOHLCV': True,
                'fetchOrder': True,
                'fetchOrders': True,
                'fetchOpenOrders': True,
                'fetchClosedOrders': True,
                'fetchTradingLimits': True,
                'fetchMyTrades': True,
                'withdraw': True,
                'fetchCurrencies': True,
                'fetchDeposits': True,
                'fetchWithdrawals': True,
            },
            'timeframes': {
                '1m': '1min',
                '5m': '5min',
                '15m': '15min',
                '30m': '30min',
                '1h': '60min',
                '4h': '4hour',
                '1d': '1day',
                '1w': '1week',
                '1M': '1mon',
                '1y': '1year',
            },
            'urls': {
                'test': {
                    'market': 'https://api.testnet.huobi.pro',
                    'public': 'https://api.testnet.huobi.pro',
                    'private': 'https://api.testnet.huobi.pro',
                },
                'logo': 'https://user-images.githubusercontent.com/1294454/76137448-22748a80-604e-11ea-8069-6e389271911d.jpg',
                'api': {
                    'market': 'https://api.huobi.pro',
                    'public': 'https://api.huobi.pro',
                    'private': 'https://api.huobi.pro',
                    'v2Public': 'https://api.huobi.pro',
                    'v2Private': 'https://api.huobi.pro',
                    'futuresPublic': 'https://api.hbdm.com',
                    'futuresPrivate': 'https://api.hbdm.com',
                    'usdtSwapPublic': 'https://api.hbdm.com',
                    'usdtSwapPrivate': 'https://api.hbdm.com',
                    'swapPublic': 'https://api.hbdm.com',
                    'swapPrivate': 'https://api.hbdm.com',
                    'futuresMarket': 'https://api.hbdm.com',
                    'swapMarket': 'https://api.hbdm.com',
                    'usdtSwapMarket': 'https://api.hbdm.com',
                },
                'www': 'https://www.huobi.pro',
                'referral': 'https://www.huobi.co/en-us/topic/invited/?invite_code=rwrd3',
                'doc': 'https://huobiapi.github.io/docs/spot/v1/cn/',
                'fees': 'https://www.huobi.pro/about/fee/',
            },
            'api': {
                'v2Public': {
                    'get': [
                        'reference/currencies',
                    ],
                },
                'v2Private': {
                    'get': [
                        'account/ledger',
                        'account/withdraw/quota',
                        'account/deposit/address',
                        'reference/transact-fee-rate',
                    ],
                    'post': [
                        'sub-user/management',
                    ],
                },
                'market': {
                    'get': [
                        'history/kline',  # 获取K线数据
                        'detail/merged',  # 获取聚合行情(Ticker)
                        'depth',  # 获取 Market Depth 数据
                        'trade',  # 获取 Trade Detail 数据
                        'history/trade',  # 批量获取最近的交易记录
                        'detail',  # 获取 Market Detail 24小时成交量数据
                        'tickers',
                    ],
                },
                'public': {
                    'get': [
                        'common/symbols',  # 查询系统支持的所有交易对
                        'common/currencys',  # 查询系统支持的所有币种
                        'common/timestamp',  # 查询系统当前时间
                        'common/exchange',  # order limits
                        'settings/currencys',  # ?language=en-US
                    ],
                },
                'private': {
                    'get': [
                        'account/accounts',  # 查询当前用户的所有账户(即account-id)
                        'account/accounts/{id}/balance',  # 查询指定账户的余额
                        'account/accounts/{sub-uid}',
                        'account/history',
                        'cross-margin/loan-info',
                        'fee/fee-rate/get',
                        'order/openOrders',
                        'order/orders',
                        'order/orders/{id}',  # 查询某个订单详情
                        'order/orders/{id}/matchresults',  # 查询某个订单的成交明细
                        'order/orders/getClientOrder',
                        'order/history',  # 查询当前委托、历史委托
                        'order/matchresults',  # 查询当前成交、历史成交
                        'dw/withdraw-virtual/addresses',  # 查询虚拟币提现地址
                        'query/deposit-withdraw',
                        'margin/loan-orders',  # 借贷订单
                        'margin/accounts/balance',  # 借贷账户详情
                        'points/actions',
                        'points/orders',
                        'subuser/aggregate-balance',
                        'stable-coin/exchange_rate',
                        'stable-coin/quote',
                    ],
                    'post': [
                        'futures/transfer',
                        'order/batch-orders',
                        'order/orders/place',  # 创建并执行一个新订单(一步下单， 推荐使用)
                        'order/orders/submitCancelClientOrder',
                        'order/orders/batchCancelOpenOrders',
                        'order/orders',  # 创建一个新的订单请求 （仅创建订单，不执行下单）
                        'order/orders/{id}/place',  # 执行一个订单 （仅执行已创建的订单）
                        'order/orders/{id}/submitcancel',  # 申请撤销一个订单请求
                        'order/orders/batchcancel',  # 批量撤销订单
                        'dw/balance/transfer',  # 资产划转
                        'dw/withdraw/api/create',  # 申请提现虚拟币
                        'dw/withdraw-virtual/create',  # 申请提现虚拟币
                        'dw/withdraw-virtual/{id}/place',  # 确认申请虚拟币提现
                        'dw/withdraw-virtual/{id}/cancel',  # 申请取消提现虚拟币
                        'dw/transfer-in/margin',  # 现货账户划入至借贷账户
                        'dw/transfer-out/margin',  # 借贷账户划出至现货账户
                        'margin/orders',  # 申请借贷
                        'margin/orders/{id}/repay',  # 归还借贷
                        'stable-coin/exchange',
                        'subuser/transfer',
                    ],
                },
                'futuresPublic': {
                    'get': [
                        'v1/contract_contract_info',  # 获取 Market ContractContractInfo
                    ],
                },
                'futuresMarket': {
                    'get': [
                        'market/history/kline',
                    ],
                },
                'futuresPrivate': {
                    'post': [
                        'v1/contract_order',  # 下单
                        'v1/contract_cancel',  # 取消订单
                        'v1/contract_hisorders',  # 未成交订单
                        'v1/contract_order_info',  # 订单信息
                        'v1/contract_order_detail',  # 订单明细,包含交易明细
                        'v1/contract_position_info',  # 持仓信息
                        'v1/contract_account_info',  # 账户余额
                    ],
                },
                'usdtSwapPublic': {
                    'get': [
                        'v1/swap_contract_info',
                    ],
                },
                'usdtSwapMarket': {
                    'get': [
                        'market/history/kline',
                    ],
                },
                'usdtSwapPrivate': {
                    'post': [
                        'v1/swap_order',
                        'v1/swap_cancel',  # 取消订单
                        'v1/swap_hisorders',  # 历史委托
                        'v1/swap_order_info',  # 订单信息
                        'v1/swap_order_detail',  # 订单明细,包含交易明细
                        'v1/swap_position_info',  # 持仓信息
                        'v1/swap_account_info',  # 账户余额
                    ],
                },
                'swapPublic': {
                    'get': [
                        'v1/swap_contract_info',
                    ],
                },
                'swapPrivate': {
                    'post': [
                        'v1/swap_order',
                        'v1/swap_cancel',  # 取消订单
                        'v1/swap_hisorders',  # 历史委托
                        'v1/swap_order_info',  # 订单信息
                        'v1/swap_order_detail',  # 订单明细,包含交易明细
                        'v1/swap_position_info',  # 持仓信息
                        'v1/swap_account_info',  # 账户余额
                    ],
                },
                'swapMarket': {
                    'get': [
                        'market/history/kline',
                    ],
                },
            },
            'fees': {
                'trading': {
                    'tierBased': False,
                    'percentage': True,
                    'maker': 0.002,
                    'taker': 0.002,
                },
            },
            'exceptions': {
                'exact': {
                    # err-code
                    'bad-request': BadRequest,
                    'api-not-support-temp-addr': PermissionDenied,  # {"status":"error","err-code":"api-not-support-temp-addr","err-msg":"API withdrawal does not support temporary addresses","data":null}
                    'timeout': RequestTimeout,  # {"ts":1571653730865,"status":"error","err-code":"timeout","err-msg":"Request Timeout"}
                    'gateway-internal-error': ExchangeNotAvailable,  # {"status":"error","err-code":"gateway-internal-error","err-msg":"Failed to load data. Try again later.","data":null}
                    'account-frozen-balance-insufficient-error': InsufficientFunds,  # {"status":"error","err-code":"account-frozen-balance-insufficient-error","err-msg":"trade account balance is not enough, left: `0.0027`","data":null}
                    'invalid-amount': InvalidOrder,  # eg "Paramemter `amount` is invalid."
                    'order-limitorder-amount-min-error': InvalidOrder,  # limit order amount error, min: `0.001`
                    'order-limitorder-amount-max-error': InvalidOrder,  # market order amount error, max: `1000000`
                    'order-marketorder-amount-min-error': InvalidOrder,  # market order amount error, min: `0.01`
                    'order-limitorder-price-min-error': InvalidOrder,  # limit order price error
                    'order-limitorder-price-max-error': InvalidOrder,  # limit order price error
                    'order-orderstate-error': OrderNotFound,  # canceling an already canceled order
                    'order-queryorder-invalid': OrderNotFound,  # querying a non-existent order
                    'order-update-error': ExchangeNotAvailable,  # undocumented error
                    'api-signature-check-failed': AuthenticationError,
                    'api-signature-not-valid': AuthenticationError,  # {"status":"error","err-code":"api-signature-not-valid","err-msg":"Signature not valid: Incorrect Access key [Access key错误]","data":null}
                    'base-record-invalid': OrderNotFound,  # https://github.com/ccxt/ccxt/issues/5750
                    # err-msg
                    'invalid symbol': BadSymbol,  # {"ts":1568813334794,"status":"error","err-code":"invalid-parameter","err-msg":"invalid symbol"}
                    'invalid-parameter': BadRequest,  # {"ts":1576210479343,"status":"error","err-code":"invalid-parameter","err-msg":"symbol trade not open now"}
                    'base-symbol-trade-disabled': BadSymbol,  # {"status":"error","err-code":"base-symbol-trade-disabled","err-msg":"Trading is disabled for self symbol","data":null}
                    'system-maintenance': OnMaintenance,  # {"status": "error", "err-code": "system-maintenance", "err-msg": "System is in maintenance!", "data": null}
                },
            },
            'options': {
                # https://github.com/ccxt/ccxt/issues/5376
                'fetchOrdersByStatesMethod': 'private_get_order_orders',  # 'private_get_order_history'  # https://github.com/ccxt/ccxt/pull/5392
                'fetchOpenOrdersMethod': 'fetch_open_orders_v1',  # 'fetch_open_orders_v2'  # https://github.com/ccxt/ccxt/issues/5388
                'createMarketBuyOrderRequiresPrice': True,
                'fetchMarketsMethod': 'publicGetCommonSymbols',
                'fetchBalanceMethod': 'privateGetAccountAccountsIdBalance',
                'createOrderMethod': 'privatePostOrderOrdersPlace',
                'language': 'en-US',
                'fetchMarkets': ['spot', 'futures', 'usdtSwap', 'swap'],
            },
            'commonCurrencies': {
                # https://github.com/ccxt/ccxt/issues/6081
                # https://github.com/ccxt/ccxt/issues/3365
                # https://github.com/ccxt/ccxt/issues/2873
                'GET': 'Themis',  # conflict with GET(Guaranteed Entrance Token, GET Protocol)
                'HOT': 'Hydro Protocol',  # conflict with HOT(Holo) https://github.com/ccxt/ccxt/issues/4929
            },
        })

    def fetch_trading_limits(self, symbols=None, params={}):
        # self method should not be called directly, use loadTradingLimits() instead
        #  by default it will try load withdrawal fees of all currencies(with separate requests)
        #  however if you define symbols = ['ETH/BTC', 'LTC/BTC'] in args it will only load those
        self.load_markets()
        if symbols is None:
            symbols = self.symbols
        result = {}
        for i in range(0, len(symbols)):
            symbol = symbols[i]
            result[symbol] = self.fetch_trading_limits_by_id(self.market_id(symbol), params)
        return result

    def fetch_trading_limits_by_id(self, id, params={}):
        request = {
            'symbol': id,
        }
        response = self.publicGetCommonExchange(self.extend(request, params))
        #
        #     {status:   "ok",
        #         data: {                                 symbol: "aidocbtc",
        #                              'buy-limit-must-less-than':  1.1,
        #                          'sell-limit-must-greater-than':  0.9,
        #                         'limit-order-must-greater-than':  1,
        #                            'limit-order-must-less-than':  5000000,
        #                    'market-buy-order-must-greater-than':  0.0001,
        #                       'market-buy-order-must-less-than':  100,
        #                   'market-sell-order-must-greater-than':  1,
        #                      'market-sell-order-must-less-than':  500000,
        #                       'circuit-break-when-greater-than':  10000,
        #                          'circuit-break-when-less-than':  10,
        #                 'market-sell-order-rate-must-less-than':  0.1,
        #                  'market-buy-order-rate-must-less-than':  0.1        }}
        #
        return self.parse_trading_limits(self.safe_value(response, 'data', {}))

    def parse_trading_limits(self, limits, symbol=None, params={}):
        #
        #   {                                 symbol: "aidocbtc",
        #                  'buy-limit-must-less-than':  1.1,
        #              'sell-limit-must-greater-than':  0.9,
        #             'limit-order-must-greater-than':  1,
        #                'limit-order-must-less-than':  5000000,
        #        'market-buy-order-must-greater-than':  0.0001,
        #           'market-buy-order-must-less-than':  100,
        #       'market-sell-order-must-greater-than':  1,
        #          'market-sell-order-must-less-than':  500000,
        #           'circuit-break-when-greater-than':  10000,
        #              'circuit-break-when-less-than':  10,
        #     'market-sell-order-rate-must-less-than':  0.1,
        #      'market-buy-order-rate-must-less-than':  0.1        }
        #
        return {
            'info': limits,
            'limits': {
                'amount': {
                    'min': self.safe_float(limits, 'limit-order-must-greater-than'),
                    'max': self.safe_float(limits, 'limit-order-must-less-than'),
                },
            },
        }

    def fetch_markets(self, params={}):
        types = self.safe_value(self.options, 'fetchMarkets')
        result = []
        for i in range(0, len(types)):
            markets = self.fetch_markets_by_type(types[i], params)
            result = self.array_concat(result, markets)
        return result

    def parse_markets(self, markets):
        result = []
        for i in range(0, len(markets)):
            result.append(self.parse_market(markets[i]))
        return result

    def parse_market(self, market):
        #
        # spot markets
        # {
        #     "quote-currency": "usdt",
        #     "price-precision": 2,
        #     "amount-precision": 6,
        #     "symbol-partition": "main",
        #     "symbol": "btcusdt",
        #     "state": "online",
        #     "value-precision": 8,
        #     "min-order-amt": 0.0001,
        #     "max-order-amt": 1000,
        #     "min-order-value": 5,
        #     "limit-order-min-order-amt": 0.0001,
        #     "limit-order-max-order-amt": 1000,
        #     "sell-market-min-order-amt": 0.0001,
        #     "sell-market-max-order-amt": 100,
        #     "buy-market-max-order-value": 1000000,
        #     "leverage-ratio": 5,
        #     "super-margin-leverage-ratio": 3,
        #     "funding-leverage-ratio": 3,
        #     "api-trading": "enabled"
        # }
        #
        # futures markets
        # {
        #     "symbol": "BTC",
        #     "contract_code": "BTC201225",
        #     "contract_type": "quarter",
        #     "contract_size": 100,
        #     "price_tick": 0.01,
        #     "delivery_date": "20201225",
        #     "create_date": "20200605",
        #     "contract_status": 1
        # }
        contractCode = self.safe_string(market, 'contract_code')
        contractType = self.safe_string(market, 'contract_type')
        type = 'spot'
        if contractCode is not None:
            if contractType is not None:
                type = 'futures'
            else:
                type = 'swap'
        baseId = ''
        id = ''
        quoteId = ''
        base = ''
        quote = ''
        symbol = ''
        spot = ''
        futures = ''
        swap = ''
        precision = {}
        active = False
        if type == 'spot':
            baseId = self.safe_string(market, 'base-currency')
            quoteId = self.safe_string(market, 'quote-currency')
            id = baseId + quoteId
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            symbol = base + '/' + quote
            futures = False
            spot = True
            swap = False
            precision = {
                'amount': market['amount-precision'],
                'price': market['price-precision'],
            }
            active = self.safe_string(market, 'state') == 'online'
        else:
            id = self.safe_string(market, 'contract_code')
            if type == 'swap':
                parts = id.split('-')
                baseId = self.safe_string(parts, 0)
                quoteId = self.safe_string(parts, 1)
                futures = False
                swap = True
            else:
                baseId = self.safe_string(market, 'symbol')
                quoteId = 'USD'
                futures = True
                swap = False
            base = self.safe_currency_code(baseId)
            quote = self.safe_currency_code(quoteId)
            symbol = id
            spot = False
            precision = {
                'amount': 1,
                'price': self.safe_float(market, 'price_tick'),
            }
            active = self.safe_float(market, 'contract_status') == 1
        maker = 0 if (base == 'OMG') else 0.2 / 100
        taker = 0 if (base == 'OMG') else 0.2 / 100
        minAmount = self.safe_float(market, 'min-order-amt', math.pow(10, -precision['amount']))
        maxAmount = self.safe_float(market, 'max-order-amt')
        minCost = self.safe_float(market, 'min-order-value', 0)
        return {
            'id': id,
            'symbol': symbol,
            'base': base,
            'quote': quote,
            'baseId': baseId,
            'quoteId': quoteId,
            'active': active,
            'precision': precision,
            'taker': taker,
            'maker': maker,
            'type': type,
            'spot': spot,
            'futures': futures,
            'swap': swap,
            'option': False,
            'limits': {
                'amount': {
                    'min': minAmount,
                    'max': maxAmount,
                },
                'price': {
                    'min': math.pow(10, -precision['price']),
                    'max': None,
                },
                'cost': {
                    'min': minCost,
                    'max': None,
                },
            },
            'info': market,
        }

    def fetch_markets_by_type(self, type, params={}):
        if type == 'spot':
            method = 'publicGetCommonSymbols'
            response = getattr(self, method)(params)
            markets = self.safe_value(response, 'data')
            return self.parse_markets(markets)
        elif type == 'futures':
            method = 'futuresPublicGetV1ContractContractInfo'
            response = getattr(self, method)(params)
            markets = self.safe_value(response, 'data')
            return self.parse_markets(markets)
        elif type == 'usdtSwap':
            method = 'usdtSwapPublicGetV1SwapContractInfo'
            response = getattr(self, method)(params)
            markets = self.safe_value(response, 'data')
            return self.parse_markets(markets)
        elif type == 'swap':
            method = 'swapPublicGetV1SwapContractInfo'
            response = getattr(self, method)(params)
            markets = self.safe_value(response, 'data')
            return self.parse_markets(markets)

    def parse_ticker(self, ticker, market=None):
        #
        # fetchTicker
        #
        #     {
        #         "amount": 26228.672978342216,
        #         "open": 9078.95,
        #         "close": 9146.86,
        #         "high": 9155.41,
        #         "id": 209988544334,
        #         "count": 265846,
        #         "low": 8988.0,
        #         "version": 209988544334,
        #         "ask": [9146.87, 0.156134],
        #         "vol": 2.3822168242201668E8,
        #         "bid": [9146.86, 0.080758],
        #     }
        #
        # fetchTickers
        #     {
        #         symbol: "bhdht",
        #         open:  2.3938,
        #         high:  2.4151,
        #         low:  2.3323,
        #         close:  2.3909,
        #         amount:  628.992,
        #         vol:  1493.71841095,
        #         count:  2088,
        #         bid:  2.3643,
        #         bidSize:  0.7136,
        #         ask:  2.4061,
        #         askSize:  0.4156
        #     }
        #
        symbol = None
        if market is not None:
            symbol = market['symbol']
        timestamp = self.safe_integer(ticker, 'ts')
        bid = None
        bidVolume = None
        ask = None
        askVolume = None
        if 'bid' in ticker:
            if isinstance(ticker['bid'], list):
                bid = self.safe_float(ticker['bid'], 0)
                bidVolume = self.safe_float(ticker['bid'], 1)
            else:
                bid = self.safe_float(ticker, 'bid')
                bidVolume = self.safe_value(ticker, 'bidSize')
        if 'ask' in ticker:
            if isinstance(ticker['ask'], list):
                ask = self.safe_float(ticker['ask'], 0)
                askVolume = self.safe_float(ticker['ask'], 1)
            else:
                ask = self.safe_float(ticker, 'ask')
                askVolume = self.safe_value(ticker, 'askSize')
        open = self.safe_float(ticker, 'open')
        close = self.safe_float(ticker, 'close')
        change = None
        percentage = None
        average = None
        if (open is not None) and (close is not None):
            change = close - open
            average = self.sum(open, close) / 2
            if (close is not None) and (close > 0):
                percentage = (change / open) * 100
        baseVolume = self.safe_float(ticker, 'amount')
        quoteVolume = self.safe_float(ticker, 'vol')
        vwap = None
        if baseVolume is not None and quoteVolume is not None and baseVolume > 0:
            vwap = quoteVolume / baseVolume
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_float(ticker, 'high'),
            'low': self.safe_float(ticker, 'low'),
            'bid': bid,
            'bidVolume': bidVolume,
            'ask': ask,
            'askVolume': askVolume,
            'vwap': vwap,
            'open': open,
            'close': close,
            'last': close,
            'previousClose': None,
            'change': change,
            'percentage': percentage,
            'average': average,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'info': ticker,
        }

    def fetch_order_book(self, symbol, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
            'type': 'step0',
        }
        response = self.marketGetDepth(self.extend(request, params))
        #
        #     {
        #         "status": "ok",
        #         "ch": "market.btcusdt.depth.step0",
        #         "ts": 1583474832790,
        #         "tick": {
        #             "bids": [
        #                 [9100.290000000000000000, 0.200000000000000000],
        #                 [9099.820000000000000000, 0.200000000000000000],
        #                 [9099.610000000000000000, 0.205000000000000000],
        #             ],
        #             "asks": [
        #                 [9100.640000000000000000, 0.005904000000000000],
        #                 [9101.010000000000000000, 0.287311000000000000],
        #                 [9101.030000000000000000, 0.012121000000000000],
        #             ],
        #             "ts":1583474832008,
        #             "version":104999698780
        #         }
        #     }
        #
        if 'tick' in response:
            if not response['tick']:
                raise ExchangeError(self.id + ' fetchOrderBook() returned empty response: ' + self.json(response))
            tick = self.safe_value(response, 'tick')
            timestamp = self.safe_integer(tick, 'ts', self.safe_integer(response, 'ts'))
            result = self.parse_order_book(tick, timestamp)
            result['nonce'] = self.safe_integer(tick, 'version')
            return result
        raise ExchangeError(self.id + ' fetchOrderBook() returned unrecognized response: ' + self.json(response))

    def fetch_ticker(self, symbol, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        response = self.marketGetDetailMerged(self.extend(request, params))
        #
        #     {
        #         "status": "ok",
        #         "ch": "market.btcusdt.detail.merged",
        #         "ts": 1583494336669,
        #         "tick": {
        #             "amount": 26228.672978342216,
        #             "open": 9078.95,
        #             "close": 9146.86,
        #             "high": 9155.41,
        #             "id": 209988544334,
        #             "count": 265846,
        #             "low": 8988.0,
        #             "version": 209988544334,
        #             "ask": [9146.87, 0.156134],
        #             "vol": 2.3822168242201668E8,
        #             "bid": [9146.86, 0.080758],
        #         }
        #     }
        #
        ticker = self.parse_ticker(response['tick'], market)
        timestamp = self.safe_value(response, 'ts')
        ticker['timestamp'] = timestamp
        ticker['datetime'] = self.iso8601(timestamp)
        return ticker

    def fetch_tickers(self, symbols=None, params={}):
        self.load_markets()
        response = self.marketGetTickers(params)
        tickers = self.safe_value(response, 'data')
        timestamp = self.safe_integer(response, 'ts')
        result = {}
        for i in range(0, len(tickers)):
            marketId = self.safe_string(tickers[i], 'symbol')
            market = self.safe_value(self.markets_by_id, marketId)
            symbol = marketId
            if market is not None:
                symbol = market['symbol']
                ticker = self.parse_ticker(tickers[i], market)
                ticker['timestamp'] = timestamp
                ticker['datetime'] = self.iso8601(timestamp)
                result[symbol] = ticker
        return self.filter_by_array(result, 'symbol', symbols)

    def parse_trade(self, trade, market=None):
        #
        # fetchTrades(public)
        #
        #     {
        #         "amount": 0.010411000000000000,
        #         "trade-id": 102090736910,
        #         "ts": 1583497692182,
        #         "id": 10500517034273194594947,
        #         "price": 9096.050000000000000000,
        #         "direction": "sell"
        #     }
        #
        # fetchMyTrades(private)
        #
        symbol = None
        if market is None:
            marketId = self.safe_string(trade, 'symbol')
            if marketId in self.markets_by_id:
                market = self.markets_by_id[marketId]
        if market is not None:
            symbol = market['symbol']
        timestamp = self.safe_integer_2(trade, 'ts', 'created-at')
        timestamp = self.safe_integer(trade, 'created_at', timestamp)
        order = self.safe_string_2(trade, 'order-id', 'order_id')
        side = self.safe_string(trade, 'direction')
        type = self.safe_string(trade, 'type')
        if type is not None:
            typeParts = type.split('-')
            side = typeParts[0]
            type = typeParts[1]
        takerOrMaker = self.safe_string(trade, 'role')
        price = self.safe_float_2(trade, 'price', 'trade_price')
        amount = self.safe_float_2(trade, 'filled-amount', 'amount')
        amount = self.safe_float(trade, 'trade_volume', amount)
        cost = None
        if market is not None and market['type'] != 'spot':
            cost = self.safe_float(trade, 'trade_turnover')
        elif price is not None:
            if amount is not None:
                cost = amount * price
        fee = None
        feeCost = self.safe_float_2(trade, 'filled-fees', 'trade_fee')
        feeCurrency = None
        if market is not None:
            feeCurrency = market['base'] if (side == 'buy') else market['quote']
        filledPoints = self.safe_float(trade, 'filled-points')
        if filledPoints is not None:
            if (feeCost is None) or (feeCost == 0.0):
                feeCost = filledPoints
                feeCurrency = self.safe_currency_code(self.safe_string(trade, 'fee-deduct-currency'))
        if feeCost is not None:
            fee = {
                'cost': feeCost,
                'currency': feeCurrency,
            }
        tradeId = self.safe_string_2(trade, 'trade-id', 'tradeId')
        id = self.safe_string(trade, 'id', tradeId)
        return {
            'id': id,
            'info': trade,
            'order': order,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'type': type,
            'side': side,
            'takerOrMaker': takerOrMaker,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': fee,
        }

    def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {}
        type = market['type']
        method = ''
        if type == 'spot':
            if symbol is not None:
                market = self.market(symbol)
                request['symbol'] = market['id']
            if limit is not None:
                request['size'] = limit  # 1-100 orders, default is 100
            if since is not None:
                request['start-date'] = self.ymd(since)  # maximum query window size is 2 days, query window shift should be within past 120 days
            response = self.privateGetOrderMatchresults(self.extend(request, params))
            trades = self.parse_trades(response['data'], market, since, limit)
            return trades
        elif type == 'futures':
            request['symbol'] = market['base']
            method = 'futuresPrivatePostV1ContractOrderDetail'
        else:
            request['contract_code'] = symbol
            if market['quote'] == 'USDT':
                method = 'usdtSwapPrivatePostV1SwapOrderDetail'
            else:
                method = 'swapPrivatePostV1SwapOrderDetail'
        orderId = self.safe_string_2(params, 'order_id', 'id')
        self.omit(params, 'order_id', 'id')
        if orderId is not None:
            request['order_id'] = orderId
        if limit is not None:
            request['page_size'] = limit
        response = getattr(self, method)(self.extend(request, params))
        trades = self.safe_value(response['data'], 'trades', [])
        return self.parse_trades(trades, market, since, limit)

    def fetch_trades(self, symbol, since=None, limit=1000, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {
            'symbol': market['id'],
        }
        if limit is not None:
            request['size'] = limit
        response = self.marketGetHistoryTrade(self.extend(request, params))
        #
        #     {
        #         "status": "ok",
        #         "ch": "market.btcusdt.trade.detail",
        #         "ts": 1583497692365,
        #         "data": [
        #             {
        #                 "id": 105005170342,
        #                 "ts": 1583497692182,
        #                 "data": [
        #                     {
        #                         "amount": 0.010411000000000000,
        #                         "trade-id": 102090736910,
        #                         "ts": 1583497692182,
        #                         "id": 10500517034273194594947,
        #                         "price": 9096.050000000000000000,
        #                         "direction": "sell"
        #                     }
        #                 ]
        #             },
        #             # ...
        #         ]
        #     }
        #
        data = self.safe_value(response, 'data')
        result = []
        for i in range(0, len(data)):
            trades = self.safe_value(data[i], 'data', [])
            for j in range(0, len(trades)):
                trade = self.parse_trade(trades[j], market)
                result.append(trade)
        result = self.sort_by(result, 'timestamp')
        return self.filter_by_symbol_since_limit(result, symbol, since, limit)

    def parse_ohlcv(self, ohlcv, market=None):
        #
        #     {
        #         "amount":1.2082,
        #         "open":0.025096,
        #         "close":0.025095,
        #         "high":0.025096,
        #         "id":1591515300,
        #         "count":6,
        #         "low":0.025095,
        #         "vol":0.0303205097
        #     }
        #
        return [
            self.safe_timestamp(ohlcv, 'id'),
            self.safe_float(ohlcv, 'open'),
            self.safe_float(ohlcv, 'high'),
            self.safe_float(ohlcv, 'low'),
            self.safe_float(ohlcv, 'close'),
            self.safe_float(ohlcv, 'amount'),
        ]

    def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=1000, params={}):
        self.load_markets()
        market = self.market(symbol)
        type = market['type']
        request = {}
        method = ''
        if type == 'spot':
            request = {
                'symbol': market['id'],
                'period': self.timeframes[timeframe],
            }
            method = 'marketGetHistoryKline'
        else:
            request = {
                'period': self.timeframes[timeframe],
            }
            if type == 'futures':
                request['symbol'] = symbol
                method = 'futuresMarketGetMarketHistoryKline'
            elif market['quote'] == 'USDT':
                request['contract_code'] = symbol
                method = 'usdtSwapMarketGetMarketHistoryKline'
            else:
                request['contract_code'] = symbol
                method = 'swapMarketGetMarketHistoryKline'
        if limit is not None:
            request['size'] = limit
        if since is not None:
            request['from'] = int(since / 1000)
        response = getattr(self, method)(self.extend(request, params))
        #
        #     {
        #         "status":"ok",
        #         "ch":"market.ethbtc.kline.1min",
        #         "ts":1591515374371,
        #         "data":[
        #             {"amount":0.0,"open":0.025095,"close":0.025095,"high":0.025095,"id":1591515360,"count":0,"low":0.025095,"vol":0.0},
        #             {"amount":1.2082,"open":0.025096,"close":0.025095,"high":0.025096,"id":1591515300,"count":6,"low":0.025095,"vol":0.0303205097},
        #             {"amount":0.0648,"open":0.025096,"close":0.025096,"high":0.025096,"id":1591515240,"count":2,"low":0.025096,"vol":0.0016262208},
        #         ]
        #     }
        #
        data = self.safe_value(response, 'data', [])
        return self.parse_ohlcvs(data, market, timeframe, since, limit)

    def fetch_accounts(self, params={}):
        self.load_markets()
        response = self.privateGetAccountAccounts(params)
        return response['data']

    def fetch_currencies(self, params={}):
        request = {
            'language': self.options['language'],
        }
        response = self.publicGetSettingsCurrencys(self.extend(request, params))
        currencies = self.safe_value(response, 'data')
        result = {}
        for i in range(0, len(currencies)):
            currency = currencies[i]
            #
            #  {                    name: "ctxc",
            #              'display-name': "CTXC",
            #        'withdraw-precision':  8,
            #             'currency-type': "eth",
            #        'currency-partition': "pro",
            #             'support-sites':  null,
            #                'otc-enable':  0,
            #        'deposit-min-amount': "2",
            #       'withdraw-min-amount': "4",
            #            'show-precision': "8",
            #                      weight: "2988",
            #                     visible:  True,
            #              'deposit-desc': "Please don’t deposit any other digital assets except CTXC t…",
            #             'withdraw-desc': "Minimum withdrawal amount: 4 CTXC. not >_<not For security reason…",
            #           'deposit-enabled':  True,
            #          'withdraw-enabled':  True,
            #    'currency-addr-with-tag':  False,
            #             'fast-confirms':  15,
            #             'safe-confirms':  30                                                             }
            #
            id = self.safe_value(currency, 'name')
            precision = self.safe_integer(currency, 'withdraw-precision')
            code = self.safe_currency_code(id)
            active = currency['visible'] and currency['deposit-enabled'] and currency['withdraw-enabled']
            name = self.safe_string(currency, 'display-name')
            result[code] = {
                'id': id,
                'code': code,
                'type': 'crypto',
                # 'payin': currency['deposit-enabled'],
                # 'payout': currency['withdraw-enabled'],
                # 'transfer': None,
                'name': name,
                'active': active,
                'fee': None,  # todo need to fetch from fee endpoint
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': math.pow(10, -precision),
                        'max': math.pow(10, precision),
                    },
                    'price': {
                        'min': math.pow(10, -precision),
                        'max': math.pow(10, precision),
                    },
                    'cost': {
                        'min': None,
                        'max': None,
                    },
                    'deposit': {
                        'min': self.safe_float(currency, 'deposit-min-amount'),
                        'max': math.pow(10, precision),
                    },
                    'withdraw': {
                        'min': self.safe_float(currency, 'withdraw-min-amount'),
                        'max': math.pow(10, precision),
                    },
                },
                'info': currency,
            }
        return result

    def fetch_balance(self, params={}):
        self.load_markets()
        self.load_accounts()
        type = self.safe_string(params, 'type', 'spot')
        quote = self.safe_string(params, 'quote', '')
        method = ''
        request = {}
        if type == 'spot':
            request = {
                'id': self.accounts[0]['id'],
            }
            method = self.options['fetchBalanceMethod']
        elif type == 'futures':
            method = 'futuresPrivatePostV1ContractAccountInfo'
        elif quote == 'USDT':
            method = 'usdtSwapPrivatePostV1SwapAccountInfo'
        else:
            method = 'swapPrivatePostV1SwapAccountInfo'
        response = getattr(self, method)(self.extend(request, params))
        balances = self.safe_value(response['data'], 'list', [])
        if type != 'spot':
            balances = self.safe_value(response, 'data', [])
        result = {'info': response}
        for i in range(0, len(balances)):
            balance = balances[i]
            if type == 'spot':
                currencyId = self.safe_string(balance, 'currency')
                code = self.safe_currency_code(currencyId)
                account = None
                if code in result:
                    account = result[code]
                else:
                    account = self.account()
                if balance['type'] == 'trade':
                    account['free'] = self.safe_float_2(balance, 'balance')
                if balance['type'] == 'frozen':
                    account['used'] = self.safe_float_2(balance, 'balance')
                result[code] = account
            else:
                account = {}
                code = None
                if type == 'swap' and quote == 'USDT':
                    code = self.safe_string(balance, 'contract_code')
                else:
                    code = self.safe_string(balance, 'symbol')
                account['free'] = self.safe_float(balance, 'margin_available')
                account['total'] = self.safe_float(balance, 'margin_balance')
                result[code] = account
        return self.parse_balance(result)

    def fetch_orders_by_states(self, states, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        type = market['type']
        method = None
        request = {}
        if type == 'spot':
            request['symbol'] = market['id']
            request['states'] = states
            method = self.safe_string(self.options, 'fetchOrdersByStatesMethod', 'private_get_order_orders')
        else:
            request['contract_code'] = symbol
            request['trade_type'] = 0
            request['type'] = 1
            request['create_date'] = 90
            request['page_size'] = 50
            request['status'] = states
            if type == 'futures':
                request['symbol'] = market['base']
                method = 'futuresPrivatePostV1ContractHisorders'
            elif market['quote'] == 'USDT':
                method = 'usdtSwapPrivatePostV1SwapHisorders'
            else:
                method = 'swapPrivatePostV1SwapHisorders'
        response = getattr(self, method)(self.extend(request, params))
        #
        #     {status:   "ok",
        #         data: [{                 id:  13997833014,
        #                                symbol: "ethbtc",
        #                          'account-id':  3398321,
        #                                amount: "0.045000000000000000",
        #                                 price: "0.034014000000000000",
        #                          'created-at':  1545836976871,
        #                                  type: "sell-limit",
        #                        'field-amount': "0.045000000000000000",
        #                   'field-cash-amount': "0.001530630000000000",
        #                          'field-fees': "0.000003061260000000",
        #                         'finished-at':  1545837948214,
        #                                source: "spot-api",
        #                                 state: "filled",
        #                         'canceled-at':  0                      }  ]}
        #
        if type == 'spot':
            return self.parse_orders(response['data'], market, since, limit)
        else:
            return self.parse_orders(response['data']['orders'], market, since, limit)

    def fetch_order(self, id, symbol=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        type = market['type']
        request = {}
        method = None
        if type == 'spot':
            request['id'] = id
            method = 'privateGetOrderOrdersId'
        elif id:
            request['order_id'] = id
        if type == 'futures':
            request['symbol'] = market['base']
            method = 'futuresPrivatePostV1ContractOrderInfo'
        elif type == 'swap' and market['quote'] == 'USDT':
            request['contract_code'] = symbol
            method = 'usdtSwapPrivatePostV1SwapOrderInfo'
        else:
            request['contract_code'] = symbol
            method = 'swapPrivatePostV1SwapOrderInfo'
        response = getattr(self, method)(self.extend(request, params))
        order = self.safe_value(response, 'data')
        if type == 'spot':
            return self.parse_order(order)
        else:
            if len(order) <= 0:
                raise OrderNotFound()
            elif len(order) == 1:
                return self.parse_order(order[0])
            else:
                result = []
                for i in range(0, len(order)):
                    result.append(self.parse_order(order[i]))
                return result

    def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        return self.fetch_orders_by_states('pre-submitted,submitted,partial-filled,filled,partial-canceled,canceled', symbol, since, limit, params)

    def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        if market['type'] == 'spot':
            method = self.safe_string(self.options, 'fetchOpenOrdersMethod', 'fetch_open_orders_v1')
            return getattr(self, method)(symbol, since, limit, params)
        else:
            return self.fetch_orders_by_states('3,4', symbol, since, limit, params)

    def fetch_open_orders_v1(self, symbol=None, since=None, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOpenOrdersV1 requires a symbol argument')
        return self.fetch_orders_by_states('pre-submitted,submitted,partial-filled', symbol, since, limit, params)

    def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        return self.fetch_orders_by_states('filled,partial-canceled,canceled', symbol, since, limit, params)

    def fetch_open_orders_v2(self, symbol=None, since=None, limit=None, params={}):
        self.load_markets()
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOpenOrders requires a symbol argument')
        market = self.market(symbol)
        accountId = self.safe_string(params, 'account-id')
        if accountId is None:
            # pick the first account
            self.load_accounts()
            for i in range(0, len(self.accounts)):
                account = self.accounts[i]
                if account['type'] == 'spot':
                    accountId = self.safe_string(account, 'id')
                    if accountId is not None:
                        break
        request = {
            'symbol': market['id'],
            'account-id': accountId,
        }
        if limit is not None:
            request['size'] = limit
        omitted = self.omit(params, 'account-id')
        response = self.privateGetOrderOpenOrders(self.extend(request, omitted))
        #
        #     {
        #         "status":"ok",
        #         "data":[
        #             {
        #                 "symbol":"ethusdt",
        #                 "source":"api",
        #                 "amount":"0.010000000000000000",
        #                 "account-id":1528640,
        #                 "created-at":1561597491963,
        #                 "price":"400.000000000000000000",
        #                 "filled-amount":"0.0",
        #                 "filled-cash-amount":"0.0",
        #                 "filled-fees":"0.0",
        #                 "id":38477101630,
        #                 "state":"submitted",
        #                 "type":"sell-limit"
        #             }
        #         ]
        #     }
        #
        data = self.safe_value(response, 'data', [])
        return self.parse_orders(data, market, since, limit)

    def parse_order_status(self, status):
        statuses = {
            'partial-filled': 'open',
            'partial-canceled': 'canceled',
            'filled': 'closed',
            'canceled': 'canceled',
            'submitted': 'open',
            '1': 'open',
            '2': 'open',
            '3': 'open',
            '4': 'open',
            '5': 'canceled',
            '6': 'closed',
            '7': 'canceled',
            '11': 'canceling',
        }
        return self.safe_string(statuses, status, status)

    def parse_order(self, order, market=None):
        #
        #     {                 id:  13997833014,
        #                    symbol: "ethbtc",
        #              'account-id':  3398321,
        #                    amount: "0.045000000000000000",
        #                     price: "0.034014000000000000",
        #              'created-at':  1545836976871,
        #                      type: "sell-limit",
        #            'field-amount': "0.045000000000000000",  # they have fixed it for filled-amount
        #       'field-cash-amount': "0.001530630000000000",  # they have fixed it for filled-cash-amount
        #              'field-fees': "0.000003061260000000",  # they have fixed it for filled-fees
        #             'finished-at':  1545837948214,
        #                    source: "spot-api",
        #                     state: "filled",
        #             'canceled-at':  0                      }
        #
        #     {                 id:  20395337822,
        #                    symbol: "ethbtc",
        #              'account-id':  5685075,
        #                    amount: "0.001000000000000000",
        #                     price: "0.0",
        #              'created-at':  1545831584023,
        #                      type: "buy-market",
        #            'field-amount': "0.029100000000000000",  # they have fixed it for filled-amount
        #       'field-cash-amount': "0.000999788700000000",  # they have fixed it for filled-cash-amount
        #              'field-fees': "0.000058200000000000",  # they have fixed it for filled-fees
        #             'finished-at':  1545831584181,
        #                    source: "spot-api",
        #                     state: "filled",
        #             'canceled-at':  0                      }
        #
        id = self.safe_string_2(order, 'id', 'order_id')
        clientOrderId = self.safe_string(order, 'client_order_id')
        side = None
        type = None
        status = None
        if 'type' in order:
            orderType = order['type'].split('-')
            side = orderType[0]
            type = orderType[1]
            status = self.parse_order_status(self.safe_string(order, 'state'))
        else:
            side = self.safe_string(order, 'direction')
            price_type = self.safe_string(order, 'order_price_type')
            price_type_map = {
                '1': 'limit',
                '2': 'market',
                '9': 'market',
            }
            type = self.safe_string(price_type_map, price_type)
            status = self.parse_order_status(self.safe_string(order, 'status'))
        symbol = None
        if market is None:
            if 'symbol' in order:
                if order['symbol'] in self.markets_by_id:
                    marketId = order['symbol']
                    market = self.markets_by_id[marketId]
        if market is not None:
            symbol = market['symbol']
        timestamp = self.safe_integer_2(order, 'created-at', 'create_date')
        timestamp = self.safe_integer(order, 'created_at', timestamp)
        amount = self.safe_float_2(order, 'amount', 'volume')
        filled = self.safe_float_2(order, 'filled-amount', 'field-amount')  # typo in their API, filled amount
        filled = self.safe_float(order, 'trade_volume', filled)
        if (type == 'market') and (side == 'buy'):
            amount = filled if (status == 'closed') else None
        price = self.safe_float(order, 'price')
        if price == 0.0:
            price = None
        cost = self.safe_float_2(order, 'filled-cash-amount', 'field-cash-amount')  # same typo
        cost = self.safe_float(order, 'trade_turnover', cost)
        remaining = None
        average = None
        if filled is not None:
            if amount is not None:
                remaining = amount - filled
            # if cost is defined and filled is not zero
            if (cost is not None) and (filled > 0):
                average = cost / filled
        if type != 'spot':
            average = self.safe_float(order, 'trade_avg_price')
        feeCost = self.safe_float_2(order, 'filled-fees', 'field-fees')  # typo in their API, filled fees
        feeCost = self.safe_float(order, 'fee', feeCost)
        fee = None
        if feeCost is not None:
            feeCurrency = None
            if market is not None:
                feeCurrency = market['quote'] if (side == 'sell') else market['base']
            fee = {
                'cost': feeCost,
                'currency': feeCurrency,
            }
        return {
            'info': order,
            'id': id,
            'clientOrderId': clientOrderId,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'average': average,
            'cost': cost,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'status': status,
            'fee': fee,
            'trades': None,
        }

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request = {}
        method = ''
        if market['spot'] is True:
            self.load_accounts()
            request = {
                'account-id': self.accounts[0]['id'],
                'symbol': market['id'],
                'type': side + '-' + type,
            }
            if (type == 'market') and (side == 'buy'):
                if self.options['createMarketBuyOrderRequiresPrice']:
                    if price is None:
                        raise InvalidOrder(self.id + " market buy order requires price argument to calculate cost(total amount of quote currency to spend for buying, amount * price). To switch off self warning exception and specify cost in the amount argument, set .options['createMarketBuyOrderRequiresPrice'] = False. Make sure you know what you're doing.")
                    else:
                        # despite that cost = amount * price is in quote currency and should have quote precision
                        # the exchange API requires the cost supplied in 'amount' to be of base precision
                        # more about it here: https://github.com/ccxt/ccxt/pull/4395
                        # we use priceToPrecision instead of amountToPrecision here
                        # because in self case the amount is in the quote currency
                        request['amount'] = self.cost_to_precision(symbol, float(amount) * float(price))
                else:
                    request['amount'] = self.cost_to_precision(symbol, amount)
            else:
                request['amount'] = self.amount_to_precision(symbol, amount)
            if type == 'limit' or type == 'ioc' or type == 'limit-maker':
                request['price'] = self.price_to_precision(symbol, price)
            method = self.options['createOrderMethod']
        else:
            request = {
                'contract_code': symbol,
                'order_price_type': type,
                'volume': int(amount),
                'direction': side,
            }
            if type == 'market':
                request['order_price_type'] = 'optimal_20'
            else:
                request['price'] = price
            if market['type'] == 'futures':
                method = 'futuresPrivatePostV1ContractOrder'
            elif market['quote'] == 'USDT':
                method = 'usdtSwapPrivatePostV1SwapOrder'
            else:
                method = 'swapPrivatePostV1SwapOrder'
        self.omit(params, 'type')
        response = getattr(self, method)(self.extend(request, params))
        timestamp = self.milliseconds()
        id = None
        if market['type'] == 'spot':
            id = self.safe_string(response, 'data')
        else:
            data = self.safe_value(response, 'data', {})
            id = self.safe_string(data, 'order_id_str')
        return {
            'info': response,
            'id': id,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'status': None,
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'amount': amount,
            'filled': None,
            'remaining': None,
            'cost': None,
            'trades': None,
            'fee': None,
            'clientOrderId': None,
            'average': None,
        }

    def cancel_order(self, id, symbol=None, params={}):
        self.load_markets()
        market = self.market(symbol)
        type = market['type']
        request = {}
        method = ''
        if type == 'spot':
            request['id'] = id
            method = 'privatePostOrderOrdersIdSubmitcancel'
        else:
            if id is not None:
                request['order_id'] = id
            if type == 'futures':
                request['symbol'] = market['base']
                method = 'futuresPrivatePostV1ContractCancel'
            elif type == 'swap' and market['quote'] == 'USDT':
                request['contract_code'] = symbol
                method = 'usdtSwapPrivatePostV1SwapCancel'
            else:
                request['contract_code'] = symbol
                method = 'swapPrivatePostV1SwapCancel'
        response = getattr(self, method)(self.extend(request, params))
        #
        #     response = {
        #         'status': 'ok',
        #         'data': '10138899000',
        #     }
        #
        return self.extend(self.parse_order(response), {
            'id': id,
            'status': 'canceled',
        })

    def currency_to_precision(self, currency, fee):
        return self.decimal_to_precision(fee, 0, self.currencies[currency]['precision'])

    def calculate_fee(self, symbol, type, side, amount, price, takerOrMaker='taker', params={}):
        market = self.markets[symbol]
        rate = market[takerOrMaker]
        cost = amount * rate
        key = 'quote'
        if side == 'sell':
            cost *= price
        else:
            key = 'base'
        return {
            'type': takerOrMaker,
            'currency': market[key],
            'rate': rate,
            'cost': float(self.currency_to_precision(market[key], cost)),
        }

    def parse_deposit_address(self, depositAddress, currency=None):
        #
        #     {
        #         currency: "eth",
        #         address: "0xf7292eb9ba7bc50358e27f0e025a4d225a64127b",
        #         addressTag: "",
        #         chain: "eth"
        #     }
        #
        address = self.safe_string(depositAddress, 'address')
        tag = self.safe_string(depositAddress, 'addressTag')
        currencyId = self.safe_string(depositAddress, 'currency')
        code = self.safe_currency_code(currencyId)
        self.check_address(address)
        return {
            'currency': code,
            'address': address,
            'tag': tag,
            'info': depositAddress,
        }

    def fetch_deposit_address(self, code, params={}):
        self.load_markets()
        currency = self.currency(code)
        request = {
            'currency': currency['id'],
        }
        response = self.v2PrivateGetAccountDepositAddress(self.extend(request, params))
        #
        #     {
        #         code: 200,
        #         data: [
        #             {
        #                 currency: "eth",
        #                 address: "0xf7292eb9ba7bc50358e27f0e025a4d225a64127b",
        #                 addressTag: "",
        #                 chain: "eth"
        #             }
        #         ]
        #     }
        #
        data = self.safe_value(response, 'data', [])
        return self.parse_deposit_address(self.safe_value(data, 0, {}), currency)

    def fetch_deposits(self, code=None, since=None, limit=None, params={}):
        if limit is None or limit > 100:
            limit = 100
        self.load_markets()
        currency = None
        if code is not None:
            currency = self.currency(code)
        request = {
            'type': 'deposit',
            'from': 0,  # From 'id' ... if you want to get results after a particular transaction id, pass the id in params.from
        }
        if currency is not None:
            request['currency'] = currency['id']
        if limit is not None:
            request['size'] = limit  # max 100
        response = self.privateGetQueryDepositWithdraw(self.extend(request, params))
        # return response
        return self.parse_transactions(response['data'], currency, since, limit)

    def fetch_withdrawals(self, code=None, since=None, limit=None, params={}):
        if limit is None or limit > 100:
            limit = 100
        self.load_markets()
        currency = None
        if code is not None:
            currency = self.currency(code)
        request = {
            'type': 'withdraw',
            'from': 0,  # From 'id' ... if you want to get results after a particular transaction id, pass the id in params.from
        }
        if currency is not None:
            request['currency'] = currency['id']
        if limit is not None:
            request['size'] = limit  # max 100
        response = self.privateGetQueryDepositWithdraw(self.extend(request, params))
        # return response
        return self.parse_transactions(response['data'], currency, since, limit)

    def parse_transaction(self, transaction, currency=None):
        #
        # fetchDeposits
        #
        #     {
        #         'id': 8211029,
        #         'type': 'deposit',
        #         'currency': 'eth',
        #         'chain': 'eth',
        #         'tx-hash': 'bd315....',
        #         'amount': 0.81162421,
        #         'address': '4b8b....',
        #         'address-tag': '',
        #         'fee': 0,
        #         'state': 'safe',
        #         'created-at': 1542180380965,
        #         'updated-at': 1542180788077
        #     }
        #
        # fetchWithdrawals
        #
        #     {
        #         'id': 6908275,
        #         'type': 'withdraw',
        #         'currency': 'btc',
        #         'chain': 'btc',
        #         'tx-hash': 'c1a1a....',
        #         'amount': 0.80257005,
        #         'address': '1QR....',
        #         'address-tag': '',
        #         'fee': 0.0005,
        #         'state': 'confirmed',
        #         'created-at': 1552107295685,
        #         'updated-at': 1552108032859
        #     }
        #
        timestamp = self.safe_integer(transaction, 'created-at')
        updated = self.safe_integer(transaction, 'updated-at')
        code = self.safe_currency_code(self.safe_string(transaction, 'currency'))
        type = self.safe_string(transaction, 'type')
        if type == 'withdraw':
            type = 'withdrawal'
        status = self.parse_transaction_status(self.safe_string(transaction, 'state'))
        tag = self.safe_string(transaction, 'address-tag')
        feeCost = self.safe_float(transaction, 'fee')
        if feeCost is not None:
            feeCost = abs(feeCost)
        return {
            'info': transaction,
            'id': self.safe_string(transaction, 'id'),
            'txid': self.safe_string(transaction, 'tx-hash'),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'address': self.safe_string(transaction, 'address'),
            'tag': tag,
            'type': type,
            'amount': self.safe_float(transaction, 'amount'),
            'currency': code,
            'status': status,
            'updated': updated,
            'fee': {
                'currency': code,
                'cost': feeCost,
                'rate': None,
            },
        }

    def parse_transaction_status(self, status):
        statuses = {
            # deposit statuses
            'unknown': 'failed',
            'confirming': 'pending',
            'confirmed': 'ok',
            'safe': 'ok',
            'orphan': 'failed',
            # withdrawal statuses
            'submitted': 'pending',
            'canceled': 'canceled',
            'reexamine': 'pending',
            'reject': 'failed',
            'pass': 'pending',
            'wallet-reject': 'failed',
            # 'confirmed': 'ok',  # present in deposit statuses
            'confirm-error': 'failed',
            'repealed': 'failed',
            'wallet-transfer': 'pending',
            'pre-transfer': 'pending',
        }
        return self.safe_string(statuses, status, status)

    def withdraw(self, code, amount, address, tag=None, params={}):
        self.load_markets()
        self.check_address(address)
        currency = self.currency(code)
        request = {
            'address': address,  # only supports existing addresses in your withdraw address list
            'amount': amount,
            'currency': currency['id'].lower(),
        }
        if tag is not None:
            request['addr-tag'] = tag  # only for XRP?
        response = self.privatePostDwWithdrawApiCreate(self.extend(request, params))
        id = self.safe_string(response, 'data')
        return {
            'info': response,
            'id': id,
        }

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        url = '/'
        if api == 'market':
            url += api
        elif (api == 'public') or (api == 'private'):
            url += self.version
        elif (api == 'v2Public') or (api == 'v2Private'):
            url += 'v2'
        elif api == 'futuresPrivate' or api == 'futuresPublic':
            url += 'api'
        elif api == 'swapPrivate' or api == 'swapPublic':
            url += 'swap-api'
        elif api == 'usdtSwapPrivate' or api == 'usdtSwapPublic':
            url += 'linear-swap-api'
        elif api == 'usdtSwapMarket':
            url += 'linear-swap-ex'
        elif api == 'swapMarket':
            url += ''
        url += '/' + self.implode_params(path, params)
        query = self.omit(params, self.extract_params(path))
        if api == 'private' or api == 'v2Private' or api == 'futuresPrivate' or api == 'swapPrivate' or api == 'usdtSwapPrivate':
            self.check_required_credentials()
            timestamp = self.ymdhms(self.milliseconds(), 'T')
            request = {
                'SignatureMethod': 'HmacSHA256',
                'SignatureVersion': '2',
                'AccessKeyId': self.apiKey,
                'Timestamp': timestamp,
            }
            if method != 'POST':
                request = self.extend(request, query)
            request = self.keysort(request)
            auth = self.urlencode(request)
            # unfortunately, PHP demands double quotes for the escaped newline symbol
            apiurl = self.safe_string(self.urls['api'], api, '')
            hostname = apiurl.replace('http://', '').replace('https://', '')
            # eslint-disable-next-line quotes
            payload = "\n".join([method, hostname, url, auth])
            signature = self.hmac(self.encode(payload), self.encode(self.secret), hashlib.sha256, 'base64')
            auth += '&' + self.urlencode({'Signature': signature})
            url += '?' + auth
            if method == 'POST':
                body = self.json(query)
                headers = {
                    'Content-Type': 'application/json',
                }
            else:
                headers = {
                    'Content-Type': 'application/x-www-form-urlencoded',
                }
        else:
            if params:
                url += '?' + self.urlencode(params)
        url = self.implode_params(self.urls['api'][api], {
            'hostname': self.hostname,
        }) + url
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if response is None:
            return  # fallback to default error handler
        if 'status' in response:
            #
            #     {"status":"error","err-code":"order-limitorder-amount-min-error","err-msg":"limit order amount error, min: `0.001`","data":null}
            #
            status = self.safe_string(response, 'status')
            if status == 'error':
                code = self.safe_string(response, 'err-code')
                feedback = self.id + ' ' + body
                self.throw_exactly_matched_exception(self.exceptions['exact'], code, feedback)
                message = self.safe_string(response, 'err-msg')
                self.throw_exactly_matched_exception(self.exceptions['exact'], message, feedback)
                raise ExchangeError(feedback)
